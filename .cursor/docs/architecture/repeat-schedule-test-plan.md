# 반복 일정 기능 테스트 설계

## 1. 테스트 범위

### 1.1 반복 일정 생성

- **매일**: 매일 일정 생성
- **매주**: 매주 같은 요일에 일정 생성
- **매월**: 매월 같은 날짜에 일정 생성 (31일 처리 포함)
- **매년**: 매년 같은 날짜에 일정 생성 (2월 29일 처리 포함)

### 1.2 반복 종료 조건

- 2025-12-31까지 최대 범위로 일정 생성
- 종료 날짜까지만 일정 생성

### 1.3 반복 일정 수정

- **단일 수정**: 해당 일정만 수정, 반복 일정에서 분리
- **전체 수정**: 반복 일정 전체 수정

### 1.4 반복 일정 삭제

- **단일 삭제**: 해당 일정만 삭제
- **전체 삭제**: 반복 일정 전체 삭제

## 2. 테스트 케이스

### 2.1 반복 일정 생성 테스트

#### TC-001: 매일 반복 일정 생성

- **Given**: 사용자가 2025-01-01부터 매일 반복 일정 생성
- **When**: 종료 날짜를 2025-12-31로 설정
- **Then**: 365개의 일정이 생성되어야 함

#### TC-002: 매주 반복 일정 생성

- **Given**: 사용자가 2025-01-01(수요일)부터 매주 반복 일정 생성
- **When**: 종료 날짜를 2025-12-31로 설정
- **Then**: 52개의 일정이 생성되어야 함 (매주 수요일)

#### TC-003: 매월 반복 일정 생성 (일반 날짜)

- **Given**: 사용자가 2025-01-15부터 매월 반복 일정 생성
- **When**: 종료 날짜를 2025-12-31로 설정
- **Then**: 12개의 일정이 생성되어야 함 (매월 15일)

#### TC-004: 매월 반복 일정 생성 (31일 처리)

- **Given**: 사용자가 2025-01-31부터 매월 반복 일정 생성
- **When**: 종료 날짜를 2025-12-31로 설정
- **Then**: 각 달의 31일에만 일정이 생성되어야 함 (1, 3, 5, 7, 8, 10, 12월만)

#### TC-005: 매년 반복 일정 생성 (일반 날짜)

- **Given**: 사용자가 2025-06-15부터 매년 반복 일정 생성
- **When**: 종료 날짜를 2025-12-31로 설정
- **Then**: 1개의 일정만 생성되어야 함 (같은 해)

#### TC-006: 매년 반복 일정 생성 (2월 29일 처리)

- **Given**: 사용자가 2024-02-29부터 매년 반복 일정 생성
- **When**: 종료 날짜를 2025-12-31로 설정
- **Then**: 1개의 일정만 생성되어야 함 (2024년만 해당)

### 2.2 반복 일정 표시 테스트

#### TC-007: 캘린더에 반복 일정 아이콘 표시

- **Given**: 반복 일정이 생성됨
- **When**: 캘린더 뷰에서 해당 일정 확인
- **Then**: 반복 일정 아이콘이 표시되어야 함

### 2.3 반복 일정 수정 테스트

#### TC-008: 단일 수정

- **Given**: 반복 일정이 존재함 (매일, 2025-01-01부터)
- **When**: 사용자가 2025-01-15 일정을 단일 수정
- **Then**: 해당 일정만 수정되고, 반복 일정에서 분리됨 (아이콘 제거)

#### TC-009: 전체 수정

- **Given**: 반복 일정이 존재함 (매일, 2025-01-01부터)
- **When**: 사용자가 2025-01-15 일정을 전체 수정
- **Then**: 반복 일정 전체가 수정되고, 아이콘 유지

### 2.4 반복 일정 삭제 테스트

#### TC-010: 단일 삭제

- **Given**: 반복 일정이 존재함 (매일, 2025-01-01부터)
- **When**: 사용자가 2025-01-15 일정을 단일 삭제
- **Then**: 해당 일정만 삭제되고, 나머지 일정은 유지

#### TC-011: 전체 삭제

- **Given**: 반복 일정이 존재함 (매일, 2025-01-01부터)
- **When**: 사용자가 2025-01-15 일정을 전체 삭제
- **Then**: 반복 일정 전체가 삭제됨

## 3. 우선순위

### High Priority

- TC-001: 매일 반복 일정 생성
- TC-004: 매월 31일 처리
- TC-008: 단일 수정
- TC-009: 전체 수정
- TC-010: 단일 삭제
- TC-011: 전체 삭제

### Medium Priority

- TC-002: 매주 반복 일정 생성
- TC-003: 매월 반복 일정 생성 (일반)
- TC-007: 반복 일정 아이콘 표시

### Low Priority

- TC-005: 매년 반복 일정 생성 (일반)
- TC-006: 매년 2월 29일 처리

## 4. 테스트 구현 전략

### 4.1 유닛 테스트

- `src/utils/repeatSchedule.ts`: 반복 일정 생성 로직 테스트
- 날짜 계산 로직 검증

### 4.2 통합 테스트

목표: UI 상에서 반복 일정 생성/수정/삭제의 end-to-end 흐름을 검증한다. 캘린더 뷰(월/주)에 발생 건이 기대대로 반영되는지까지 포함한다.

#### 테스트 환경/도구

- 테스트 러너: Vitest
- 렌더링: React Testing Library
- 상호작용: `@testing-library/user-event`
- 시간 고정: `vi.setSystemTime(new Date('2025-01-01T00:00:00'))`
- 네트워크/스토리지: 실제 API 호출 없음. 로컬 상태/컨텍스트 기반이면 그대로 사용. 필요 시 `localStorage` mock
- 병렬 안전성: 각 케이스는 독립 상태를 사용하여 병렬 실행해도 간섭이 없어야 함
- API 격리: API가 개입되는 경우 반드시 `src/__mocks__/handlersUtils.ts`로 각 테스트별 독립 핸들러 구성
- 레퍼런스: `src/__tests__/medium.integration.spec.tsx`의 환경 구성/패턴을 우선 참고

#### 공통 시나리오 흐름 (Given-When-Then)

- Given: 메인 `App`을 렌더링하고 초기 날짜를 2025-01-01로 고정한다
- When: 일정 생성 다이얼로그를 열고 반복 옵션을 설정한 뒤 저장한다
- Then: 월/주 뷰에서 해당 발생 건들이 정확히 표시되는지 확인한다

#### UI 조작 가이드

- 일정 생성: "일정 추가" 버튼 클릭 → 폼 입력(`title`, `date`, `startTime`, `endTime`, `repeat.type`, `repeat.interval`, `repeat.endDate`) → 저장
- 반복 설정: MUI Select 사용 시 값은 `daily|weekly|monthly|yearly` 중 하나를 사용하고, 미선택은 빈 문자열('')로 처리하여 out-of-range 경고 방지
- 뷰 전환: 상단 탭/버튼으로 "월간"/"주간" 전환 → 렌더된 셀 내 텍스트로 이벤트 노출 여부 확인

#### 병렬 실행 및 API 격리 전략

- 각 테스트는 독립적인 초기 상태를 갖도록 한다
  - API 상호작용이 필요하면 `handlersUtils`의 팩토리 함수로 매 테스트마다 핸들러를 구성
  - `beforeEach`에서 `server.resetHandlers()` 호출로 핸들러/상태 초기화
- 전역 시계 고정은 테스트 간 공유되므로 `beforeEach`에서 매번 고정/해제 처리
- DOM 컨테이너는 `render` 호출로 테스트마다 신규 생성하여 공유 금지

예시:

```ts
// 공통: src/__tests__/integration/setup.ts (선택)
import { server } from '../../setupTests';
import { vi } from 'vitest';

beforeEach(() => {
  server.resetHandlers();
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-01T00:00:00'));
});

afterEach(() => {
  vi.useRealTimers();
});
```

```ts
// 케이스별: src/__tests__/integration/repeatSchedule.integration.spec.tsx (제안)
import { setupMockHandlerCreation } from '../../__mocks__/handlersUtils';

it('INT-001: 매일 반복 생성 후 월/주 뷰 표시 검증', async () => {
  setupMockHandlerCreation([]); // 테스트 전용 초기 상태
  // App 렌더 → 폼 입력 → 저장 → 월/주 뷰 검증
});
```

#### 케이스 목록 (INT)

- INT-001 생성/표시: 매일 반복 생성 → 월/주 뷰 모두에서 발생 건 일부 샘플이 표시됨을 확인
- INT-002 단일 수정: 2025-01-15 발생을 단일 수정 → 해당 건은 반복 아이콘 제거(분리), 나머지는 유지
- INT-003 전체 수정: 2025-01-15 발생 기준 전체 수정 → 모든 발생에 제목/시간 반영, 반복 아이콘 유지
- INT-004 단일 삭제: 2025-01-15 발생만 삭제 → 다른 발생 건은 그대로 유지
- INT-005 전체 삭제: 2025-01-15 발생 기준 전체 삭제 → 동일 `repeat.id` 그룹 모두 사라짐

각 케이스는 다음 공통 검증을 수행한다:

- 월간/주간 뷰에서 표출 여부 검증(텍스트 매칭 및 발생 수 샘플 확인)
- 발생 건 개수 변화(추가/삭제/유지) 검증
- 반복 아이콘 노출/제거 상태 검증(분리 여부 확인용)

#### 구현 스켈레톤 예시

```ts
// src/__tests__/integration/repeatSchedule.integration.spec.tsx (제안)
describe('반복 일정 - 통합', () => {
  beforeEach(() => {
    vi.setSystemTime(new Date('2025-01-01T00:00:00'));
  });

  it('INT-001: 매일 반복 생성 후 월/주 뷰 표시 검증', async () => {
    render(<App />);
    await user.click(screen.getByRole('button', { name: /일정 추가/i }));
    // 폼 채우기: title/date/time/repeat(endDate 포함)
    // 저장 후 월간/주간 뷰에서 샘플 날짜(1/1, 1/2, 1/15 등) 노출 확인
  });

  it('INT-002: 단일 수정 분리 확인', async () => {
    // 생성 → 1/15 셀에서 일정 클릭 → 편집 → 제목 변경 저장
    // 1/15만 변경되고 반복 아이콘 제거(분리), 다른 날짜는 기존 제목 유지
  });

  it('INT-005: 전체 삭제로 모든 발생 제거', async () => {
    // 생성 → 1/15 셀에서 일정 클릭 → 삭제(전체) → 월/주 뷰에서 동일 그룹 일정 미노출 확인
  });
});
```
